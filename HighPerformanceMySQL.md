# 高性能MySQL笔记

## 1.MySQL

### 1.1MySql逻辑架构

![image-20210716135920298](C:\Users\cai\AppData\Roaming\Typora\typora-user-images\image-20210716135920298.png)

第二层架构是 MySQL 比较有意思的部分。大多数 MySQL 的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加 密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。

第三层包含了存储引擎。存储引擎负责 MySQL 中数据的存储和提取



### 1.2并发控制

#### 1.2.1读写锁

并发控制主要通过读写锁实现。

这两种类型的锁通常被称为**共享锁 (shared lock)** 和**排他锁 (exclusive lock)** ，也叫**读锁 (read lock)** 和**写锁 (write lock)**

**读锁是共享的**，或者说是相互不阻塞的。**多个客户在同一时刻可以同时读取同一个资源**，而互不干扰。

**写锁则是排他的**， 也就是说**一个写锁会阻塞其他的写锁和读锁**。

#### 1.2.2锁粒度

一种提高共享资源并发性的方式就是让锁定对象更有选择性。**尽量只锁定需要修改的部分数据，而不是所有的资源**。

任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。

所谓的锁策略，就是**在锁的开销和数据的安全性之间寻求平衡**，这种平衡当然也会影响到性能。

**表锁（table lock)**:

表锁是 MySQL中最基本的锁策略，并且是开销最小的策略。表锁非常类似前文描述的邮箱加锁机制：**它会锁定整张表**。一个用户在对表进行写操作（插人、删除、更新等） 前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，**读锁之间是不相互阻塞的**。

**行级锁（row lock）**

行级锁可以最大程度地支持井发处理（同时也带来了最大的锁开销）。众所周知，在 InnoDB XtraDB, 以及其他一些存储引擎中实现了行级锁。行级锁只在存储引擎层实 现，而 MySQL 服务器层（如有必要，请回顾前文的逻辑架构图）没有实现



### 1.3事务

事务就是一组原 子性的 SQL 查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语旬因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。

**原子性 (atomicity)** 

​		一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，**对一个事务来说，不可能只执行其中的一部分操作**，这就是事务的原子性。

 **一致性 (consistency)** 

​		数据库总是**从一个一致性的状态转换到另外一个一致性的状态**。

**隔离性 (isolation)**

​		通常来说，**一个事务所做的修改在最终提交以前，对其他事务是不可见的**。

**持久性 (durability)**

 		**一且事务提交，则其所做的修改就会永久保存到数据库中**。此时即使系统崩溃，修改的数据也不会丢失。持久性是个有点模糊的概念，因为实际上持久性也分很多 不同的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。而且不可能有能做到 100％的持久性保证的策略

#### 1.3.1隔离级别

**READ UNCOMMITTED （未提交读）**

​		在READ UNCOMMITTED 级别，**事务中的修改即使没有提交，对其他事务也都是可见的**。事务可以读取未提交的数据，这也被称为**脏读 (Dirty Read)** 。这个级别会导致很多问题，从性能上来说， READ UNCOMMITTED 不会比其他的级别好太多，但却缺乏其他级别的很多好处，除非真的有非常必要的理由，在实际应用中一般很少使用。

**READ COMMITTED （提交读）**

​		大多数数据库系统的默认隔离级别都是 READ COMMITTED （但 MySQL 不是）。 READ COMMITTED 满足前面提到的隔离性的简单定义：**一个事务开始时，只能“看见”已经提交的事务所做的修改**。换句话说，**一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的**。这个级别有时候也叫做不可重复读 (nonrepeatable read) ，因为两次执行同样的查询，可能会得到不一样的结果。

**REPEATABLE READ （可重复读）**

​		REPEATABLE READ **解决了脏读的问题**。**该级别保证了在同一个事务中多次读取同样记录的结果是一致的**。但是理论上，可重复读隔离级别还是无法解决另外一个**幻读 (Phantom Read) 的问题**。所谓**幻读，指的是当某个事务在读取某个范围内的记录时， 另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行 (Phantom Row)** 。InnoDB XtraDB 存储引擎通过**多版本并发控制(MVCC, Multiversion Concurrency Control)** 解决了幻读的问题。**可重复读是 MySQL 的默认事务隔离级别。**

**SERIALIZABLE （可串行化）**

​		SERIALIZABLE 是**最高的隔离级别**。它通过**强制事务串行执行**，避免了前面说的幻读的问题。简单来说， **SERIALIZABLE 会在读取的每一行数据上都加锁**，所以**可能导致大量的超时和锁争用的问题**。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有井发的情况下，才考虑采用该级别。

![image-20210716142726912](C:\Users\cai\AppData\Roaming\Typora\typora-user-images\image-20210716142726912.png)

补充：

一些典型不一致现象：

**丢失修改**：两个事务对同一数据进行修改，其中一个修改被另一个修改覆盖。

**不可重复读**：在一个事务对一个数据的两次读取之间，另一个事务对此数据进行了修改，导致两次读取读到的数据不一致

**读脏数据**：事务A对数据进行了修改，然后事务B读取了这一数据，但由于一些特殊原因事务A进行了回滚操作，使事务B在这之前读到的数据为脏数据，造成不一致

**幻读**：主要出现在范围查询中。当某个事务在读取某个范围内的记录时， 另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行

#### 1.3.2死锁

**死锁是指两个或者多个事务在同一资源上相互占用，井请求锁定对方占用的资源，从而导致恶性循环**的现象。当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。 多个事务同时锁定同一个资源时，也会产生死锁。

为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统， 比如 InnoDB 存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。这种解决方式很有效，否则死锁会导致出现非常慢的查询。还有一种解决方式，就是**当查询的时间达到锁等待超时的设定后放弃锁请求**，这种方式通常来说不太好。 **InnoDB 目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚（这是相对比较简单的死锁回滚算法）**。

死锁的产生有双重原因：有些是因为真正的数据冲突，这种情况通常 很难避免，但有些则完全是由于存储引擎的实现方式导致的。

死锁发生以后，**只有部分或者完全回滚其中一个事务，才能打破死锁**。对于事务型的系统，这是无法避免的

**补充：**

**活锁**：锁在多个事务之间传递，而有一个或多个事务一直处于等待状态获取不到锁。使用FCFS先来先服务解决。

**死锁诊断**：超时法，等待图法。

**死锁预防**：一次封锁，每个事务在执行前将要使用的全部数据加锁。顺序封锁，预先对数据对象规定一个封锁顺序，所有事务都按照这个顺序实施封锁

**死锁解除**：选择一个处理死锁代价最小的事务将其撤销。

#### 1.3.3事务日志

事务日志可以帮助提高事务的效率。

使用事务日志，**存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘**。

**事务日志采用的是追加的方式**，因此**写日志的操作是磁盘 上一小块区域内的顺序 I/O, 而不像随机 I/O 需要在磁盘的多个地方移动磁头**，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，**内存中被修改的数据在后台可以慢慢地刷回到磁盘**。目前大多数存储引擎都是这样实现的，我们通常称之为**预写式日志** (Write-Ahead Logging) ，修改数据需要**写两次磁盘**。第1次写磁盘：将修改行为持久化到事务日志。第2次写磁盘：将内存中被修改的数据刷回磁盘。

如果数据的修改已经记录到事务日志井持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。

#### 1.3.4MySQL中的事务

**自动提交 (AUTOCOMMIT)**

MySQL 默认采用自动提交 (AUTOCOMMIT) 模式。也就是说，**如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作**。

**InnoDB的锁定**

InnoDB 采用的是**两阶段锁定协议 (two-phase locking protocol)** 。**在事务执行过程中，随时都可以执行锁定，锁只有在执行 COMMIT 或者 ROLLBACK 的时候才会释放，并且所有的锁是在同一时刻被释放**。前面描述的锁定都是隐式锁定， InnoDB 会根据隔离级别在需 要的时候自动加锁。

### 1.4多版本并发控制（MVCC）

MySQL 的大多数事务型存储引擎实现的都不是简单的行级锁。基千提升井发性能的考 虑，它们一般都同时实现了多版本并发控制 (MVCC) 。

InnoDB MVCC, 是通过**在每行记录后面保存两个隐藏的列**来实现的。这两个列，**一 个保存了行的创建时间**，**一个保存行的过期时间（或删除时间）**。当然存储的并不是实际的时间值，而是**系统版本号 (system version number)** 。**每开始一个新的事务，系统版本号都会自动递增**。**事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。**

**SELECT**

InnoDB 会根据以下两个条件检查每行记录： 

a. **InnoDB 只查找版本早于当前事务版本的数据行**（也就是，行的系统版本号小于或等与事务的系统版本号），这样可以**确保事务读取的行，要么是在事务开 始前已经存在的，要么是事务自身插入或者修改过的。**

 b. **行的删除版本要么未定义，要么大于当前事务版本号**。这**可以确保事务读取到的行，在事务开始之前未被删除**。 只有符合上述两个条件的记录，才能返回作为查询结果。

**INSERT** 

InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。

**DELETE**

InnoDB 为删除的每一行保存当前系统版本号作为行删除标识。

**UPDATE**

InnoDB 为插入一行新记录，**保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。**这里相当于删掉旧的，再插入新的

**保存这两个额外系统版本号，使大多数读操作都可以不用加锁**。这样设计使得读数据操作很简单，性能很好，井且也能保证只会读取到符合标准的行。不足之处是每行记录都 需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。

**MVCC 只在 REPEATABLE READ，READ COMMITTED 两个隔离级别下工作**。其他两个隔离 级别都和 MVCC 不兼容注 ，因为 READ UNCOMMITTED 总是读取最新的数据行，而不是符合 当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。

### 1.5MySQL的存储引擎

在文件系统中， MySQL 将每个数据库（也可以称之为 schema) 保存为数据目录下的一个子目录。创建表时， MySQL 会在数据库子目录下创建一个和表同名的．frm 文件保存表的定义。

因为 MySQL 使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感性和具体的平台密切相关。在 Windows 中，大小写是不敏感的；而在类 Unix 中则是敏感的。

#### 1.5.1InnoDB存储引擎

InnoDB 的数据存储在表空间 (tablespace) 中，表空间是由 InnoDB 管理的一个黑盒子， 由一系列的数据文件组成。

**InnoDB 采用 MVCC 来支持高井发，并且实现了四个标准的隔离级别**。其默认级别是 REPEATABLE READ （可重复读），并且**通过间隙锁 (next-key locking) 策略防止幻读的出现**。 **间隙锁使得 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入**。

InnoDB 表是**基于聚簇索引建立的**，我们会在后面的章节详细讨论聚簇索引。 InnoDB 索引结构和 MySQL 的其他存储引擎有很大的不同，**聚簇索引对主键查询有很高的性能**。 **不过它的二级索引 (secondary index, 非主键索引）中必须包含主键列**，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应当尽可 能的小。

InnoDB 内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在 内存中创建 hash 索引以加速读操作的自适应哈希索引 (adaptive hash index) ，以及能够加速插入操作的插入缓冲区 (insert buffer) 等

#### 1.5.2MyISAM存储引擎

**MyISAM 不支持事务和行级锁**，且有一个毫无疑问的缺陷就是**崩溃后无法安全恢复**。。尽管 MyISAM 引擎不支持事务、不支持崩溃后的安全恢复，但它绝不是一无是处。**对于只读的数据，或者表比较小、可以忍受修复 (repair) 操作，则依然可以继续使 MyISAM** （但请**不要默认使用 MylSAM, 而是应当默认使用 lnnoDB**)

**MylSAM 特性**

加锁与并发

​		**MyISAM 对整张表加锁，而不是针对行**。**读取时会对需要读到的所有表加共享锁， 写入时则对表加排他锁**。但是在表有读取查询的同时，也可以往表中插入新的记录 （这被称为井发插入， CONCURRENT INSERT)

......

MylSAM 性能

MyISAM 引擎设计简单，数据以紧密格式存储，所以在某些场景下的性能很好。 MyISAM 有一些服务器级别的性能扩展限制，比如对索引键缓冲区 (key cache) Mutex 锁， MariaDB 基于段 (segment) 的索引键缓冲区机制来避免该问题。但 MyISAM 最典型的性能问题还是表锁的问题，如果你发现所有的查询都长期处千 “Locked" 状态， 那么毫无疑问表锁就是罪魁祸首。

#### 1.5.5选择合适的引擎

这么多存储引擎，我们怎么选择？**大部分情况下， InnoDB 都是正确的选择**，所以 Oracle MySQL 5.5 版本时终千将 InnoDB 作为默认的存储引擎了。对于如何选择存储引擎， 可以简单地归纳为一句话：“**除非需要用到某些 InnoDB 不具备的特性，并且没有其他办法可以替代，否则都应该优先选择 InnoDB 引擎**＂。例如，如果要用到全文索引，建议优先考虑 InnoDB 加上 Sphinx 的组合，而不是使用支持全文索引的 MyISAM 。当然，如果不需要用到 InnoDB 的特性，同时其他引擎的特性能够更好地满足需求，也可以考虑一 下其他存储引擎。

举个例子，如果不在乎可扩展能力和井发能力，也不在乎崩溃后的数 据丢失问题，却对 InnoDB 的空间占用过多比较敏感，这种场合下选择 MylSAM 就比较 合适。 **除非万不得已，否则建议不要混合使用多种存储引擎，否则可能带来一系列复杂的问题， 以及一些潜在的 bug 和边界问题**。存储引擎层和服务器层的交互已经比较复杂，更不用 说混合多个存储引擎了。至少，混合存储对一致性备份和服务器参数配置都带来了一些 困难



## 4.Schema与数据类型优化

良好的逻辑设计和物理设计是高性能的基石，应该根据系统将要执行的查询语句来设计 schema, 这往往需要权衡各种因素。

### 4.1选择优化的数据类型

**更小的通常更好**

​		一般情况下，**应该尽最使用可以正确存储数据的最小数据类型** 。**更小的数据类型通常更快，因为它们占用更少的磁盘、内存和 CPU 缓存**，**并且处理时需要的 CPU周期也更少**。 **但是要确保没有低估需要存储的值的范围**，因为**在 schema 中的多个地方增加数据类型的范围是一个非常耗时和痛苦的操作**。如果无法确定哪个数据类型是最好的，就选择你认为不会超过范围的最小类型。（如果系统不是很忙或者存储的数据量不多， 或者是在可以轻易修改设计的早期阶段，那之后修改数据类型也比较容易）。

**简单就好**

​		**简单数据类型的操作通常需要更少的 CPU 周期**。例如，整型比字符操作代价更低， 因为字符集和校对规则（排序规则）使字符比较比整型比较更复杂。这里有两个例子： 一个是应该使用 MySQL 内建的类型注而不是字符串来存储日期和时间，另外一个 是应该用整型存储 IP 地址。

**尽量避免 NULL**

​		很多表都包含可为 NULL （空值）的列，即使应用程序并不需要保存 NULL 也是如此， 这是因为可为 NULL是列的默认属性注。**通常情况下最好指定列为 NOT NULL, 除非真的需要存储 NULL 值**。

​		如果查询中包含可为 NULL 的列，**对 MySQL 来说更难优化，因为可为 NULL 的列使得索引、索引统计和值比较都更复杂**。可为 NULL 的列会使用更多的存储空间，在 MySQL 里也需要特殊处理。当可为 NULL 的列被索引时，每个索引记录需要一个额外的字节，在 MyISAM 里甚至还可能导致固定大小的索引（例如只有一个整数列的 索引）变成可变大小的索引。



在为列选择数据类型时**，第一步需要确定合适的大类型：数字、字符串、时间**等。**下一步是选择具体类型**。很多 MySQL 的数据类型可以存储相同类型的数据，只是存储的长度和范围不一样、允许的精度不同，或者需要的物理空间（磁盘和内存空间）不同。

#### 4.1.1整数类型

有两种类型的数字：**整数 (whole number)** 和**实数 (real number)** 。如果存储整数，可 以使用这几种整数类型： **TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT**。分别使用 8, 16, 24, 32, 64 位存储空间。它们可以存储的值的范围从－ N“ 2(N 1)_1, 其中 存储空间的位数。

 **整数类型有可选的 UNSIGNED 属性，表示不允许负值，这大致可以使正数的上限提高一倍**。 例如 TINYINT. UNSIGNED 可以存储的范围是 - 255, TINYINT 的存储范围是－l28 ~  127 有符号和无符号类型使用相同的存储空间，并具有相同的性能，因此可以根据实际情况 选择合适的类型。

**有符号和无符号类型使用相同的存储空间，并具有相同的性能**，因此可以根据实际情况 选择合适的类型。

#### 4.1.2实数类型

实数是带有小数部分的数字。然而，它们不只是为了存储小数部分，也可以使用 DECIMAL 存储比 BIGINT 还大的整数。 MySQL 既支持精确类型，也支持不精确类型。

#### 4.1.3字符串类型

**VARCHAR**

VARCHAR 类型**用于存储可变长字符串**，是最常见的字符串数据类型。它**比定长类型更节省空间**，因为**它仅使用必要的空间**（例如，越短的字符串使用越少的空间）。

**VARCHAR 需要使用1或2个额外字节记录字符串的长度**：如果列的最大长度小千或 等于 255 字节，则只使用 个字节表示，否则使用 个字节。

VARCHAR 节省了存储空间，所以对性能也有帮助。但是，**由于行是变长的，在 UPDATE 时可能使行变得比原来更长，这就导致需要做额外的工作**。例如， MyISAM 会将行拆成不同的片段存储， InnoDB 则需要分裂页来使行可以放进页内。其他一些存储引擎也许从不在原数据位置更新数据。**可能会产生碎片**。

下面这些情况下使用 VARCHAR 是合适的：**字符串列的最大长度比平均长度大很多**，**列的更新很少，所以碎片不是问题**，使用了像 UTF-8 这样复杂的字符集，每个字符 都使用不同的字节数进行存储。



**CHAR**

**CHAR 类型是定长的**： **MySQL 总是根据定义的字符串长度分配足够的空间**。当存储 CHAR 值时， MySQL **会删除所有的末尾空格**。

**CHAR 适合存储很短的字符串**，或者**所有值都接近同一个长度**。例如， CHAR非常适 合存储密码的 MD5 值，因为这是一个定长的值。**对于经常变更的数据， CHAR 也比 VARCHAR 更好，因为定长的 CHAR 类型不容易产生碎片**。对于非常短的列， CHAR VARCHAR 在存储空间上也更有效率。例如用 CHAR(l) 来存储只有 的值，如果 采用单字节字符集只需要一个字节，但是 VARCHAR(l) 却需要两个字节，因为还有一个记录长度的额外字节。

数据如何存储取决于存储引擎，**并非所有的存储引擎都会按照相同的方式处理定长和变长的字符串**。 



**BLOB和TEXT类型**

BLOB TEXT 都是**为存储很大的数据而设计的字符串数据类型**，分别采用**二进制**和**字符方式**存储。

BLOB TEXT 家族之间仅有的不同是 **BLOB 类型存储的是二进制数据，没有排序规则或字符集，而 TEXT 类型有字符集和排序规则**。



枚举ENUM

....



#### 4.1.4日期和时间类型

**DATEATIME**

​		这个类型能保存大范围的值，从 1001 年到 9999 年，精度为秒。它把日期和时间封装到格式为 YYYYMMDDHHMMSS 的整数中，与时区无关。使用8个字节的存储空间。

**TIMESTAMP**

​		就像它的名字一样， TIMETAMP 类型保存了从 1970年1月1日午夜（格林尼治标准 时间）以来的秒数，它和 UNIX 时间戳相同。TIMESTAMP 只使用4个字节的存储空间， 因此它的范围比 DATETIME 小得多：只能表示从 1970 年到 2038 年。 MySQL 提供了 FROM_UNIXTIME( ）函数把 Unix 时间戳转换为日期，井提供了 UNIX_TIMESTAMP( ）函 数把日期转换为 Unix 时间戳。

除了特殊行为之外，通常也应该尽量使用 TIMESTAMP, 因为它比 DATETIME 空间效率更高。



#### 4.1.6选择标识符 (identifier)

为标识列 (identifier column) 选择合适的数据类型非常重要。一般来说更有可能用标识 列与其他值进行比较（例如，在关联操作中），或者通过标识列寻找其他列。标识列也可能在另外的表中作为外键使用，所以为标识列选择数据类型时，应该选择跟关联表中 的对应列一样的类型

**整数类型**

​	整数通常是标识列最好的选择，因为它们**很快并且可以使用 AUTO_INCREMENT**

**ENUM SET 类型**

​		对于标识列来说， EMUM SET 类型通常是一个糟糕的选择，尽管对某些只包含固定 状态或者类型的静态”定义表”来说可能是没有问题的。 ENUM SET 列适合存储固 定信息，例如有序的状态、产品类型、人的性别。

**字符串类型**

​		如果可能，应该避免使用字符串类型作为标识列，因为**它们很消耗空间，并且通常比数字类型慢**。尤其是在 MyISAM 表里使用字符串作为标识列时要特别小心。 MylSAM 默认对字符串使用压缩索引，这会导致查询慢得多。

​		对千完全”随机”的字符串也需要多加注意，例如 MDS( ）、 SHAl( ）或者 UUID( ）产生 的字符串。**这些函数生成的新值会任意分布在很大的空间内**，这会导致 INSERT 以及 一些 SELECT 语句变得很慢

因为**插入值会随机地写到索引的不同位置**，所以使得 INSERT 语句更慢。这会导致页分裂、磁盘随机访问，以及对千聚簇存储引擎产生聚簇索引碎片。

SELECT 语句会变得更慢，因为**逻辑上相邻的行会分布在磁盘和内存的不同地方**。

**随机值导致缓存对所有类型的查询语句效果都很差**，因为会使得缓存赖以工作的**访问局部性原理失效**。如果整个数据集都一样的“热”，那么缓存任何一部分特定数据到内存都没有好处；如果工作集比内存大，缓存将会有很多刷新和不命中。



### 4.2MySQL schema 设计中的陷阱

**太多的列**

...

**太多的关联**

所谓的“实体－属性－值”(EAV) 设计模式是一个常见的糟糕设计模式，尤其是在 MySQL 下不能靠谱地工作。。一个粗略的经验法则，如果希望查询执行得快速且井发性好，单个查询最好在 12 个表以内做关联。

....



### 4.3范式与反范式

对千任何给定的数据通常都有很多种表示方法，从完全的范式化到完全的反范式化，以及两者的折中。**在范式化的数据库中，每个事实数据会出现并且只出现一次**。相反，**在反范式化的数据库中，信息是冗余的，可能会存储在多个地方**。

#### 4.3.1范式的优点和缺点

当为性能问题而寻求帮助时，经常会被建议对 schema 进行范式化设计，尤其是写密集的场景。

- 范式化的更新操作通常比反范式化要快。
- 当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据。
- 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快。
- 很少有多余的数据意味着检索列表数据时更少需要 DISTINCT 或者 GROUP BY 语句。

范式化设计的 schema的**缺点是通常需要关联**。稍微复杂一些的查询语句在符合范式的 schema 上都可能需要至少一次关联，也许更多。**这不但代价昂贵，也可能使一些索引策略无效**。例如，范式化可能将列存放在不同的表中，而这些列如果在一个表中本可以属 千同一个索引。

#### 4.3.2反范式的优点

反范式化的 schema 因为所有数据都在一张表中，可以很好地避免关联。

如果不需要关联表，则对大部分查询最差的情况——即使表没有使用索引——是全表扫 描。当数据比内存大时这可能比关联要快得多，因为这样避免了随机 I/0

#### **4.3.3混用范式化和反范式化**

完全的范式化和完全的反范式化 schema 都是实验室里才有的东西：在真实世界中很少会这么极端地使用。在实际应用中经常需要混用，可能使用部分范式化的 schema 、缓存表，以及其他技巧。

最常见的反范式化数据的方法是**复制或者缓存**，**在不同的表中存储相同的特定列**。



### 4.4缓存表与汇总表

#### 4.4.2 计数器表

如果应用在表中保存计数器，则在更新计数器时可能碰到井发问题。这会使得这些事务只能串行执行。要获得更高的并发更新性能，也可以**将计数器保存在多行中，每次随机选择一行进行更新**。在统计时使用聚合查询求和即可



### 4.5 加快 ALTER TABLE 操作的速度

一般而言，**大部分 ALTER TABLE 操作将导致 MySQL 服务中断**。

对常见的场景，能使用的技巧只有两种：

一种是**先在一台不提供服务的机器上执行 ALTER TABLE 操作，然后和提供服务的主库进行切换**；

另外一种技巧是“**影子拷贝**＂。影子拷贝的技巧是**用要求的表结构创建一张和源表无关的新表**，**然后通过重命名和删表操作交换两张表**。

#### 4.5.2 快速创建 MylSAM 索引

为了高效地载人数据到 MyISAM 表中，有一个常用的技巧是先禁用索引、载入数据，然 后重新启用索引



## 5创建高性能的索引

**索引对于良好的性能非常关键**。尤其是**当表中的数据量越来越大时，索引对性能的影响愈发重要**。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但**当数据址逐渐增大时，性能则会急剧下降**。

**5.1索引基础**