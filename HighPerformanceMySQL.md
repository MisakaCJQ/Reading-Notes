# 高性能MySQL笔记

## 1.MySQL

### 1.1MySql逻辑架构

<img src="./screen shot/HighPerformanceMySQL/1.png" alt="image-20210716135920298"  />

第二层架构是 MySQL 比较有意思的部分。大多数 MySQL 的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加 密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。

第三层包含了存储引擎。存储引擎负责 MySQL 中数据的存储和提取



### 1.2并发控制

#### 1.2.1读写锁

并发控制主要通过读写锁实现。

这两种类型的锁通常被称为**共享锁 (shared lock)** 和**排他锁 (exclusive lock)** ，也叫**读锁 (read lock)** 和**写锁 (write lock)**

**读锁是共享的**，或者说是相互不阻塞的。**多个客户在同一时刻可以同时读取同一个资源**，而互不干扰。

**写锁则是排他的**， 也就是说**一个写锁会阻塞其他的写锁和读锁**。

#### 1.2.2锁粒度

一种提高共享资源并发性的方式就是让锁定对象更有选择性。**尽量只锁定需要修改的部分数据，而不是所有的资源**。

任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。

所谓的锁策略，就是**在锁的开销和数据的安全性之间寻求平衡**，这种平衡当然也会影响到性能。

**表锁（table lock)**:

表锁是 MySQL中最基本的锁策略，并且是开销最小的策略。表锁非常类似前文描述的邮箱加锁机制：**它会锁定整张表**。一个用户在对表进行写操作（插人、删除、更新等） 前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，**读锁之间是不相互阻塞的**。

**行级锁（row lock）**

行级锁可以最大程度地支持井发处理（同时也带来了最大的锁开销）。众所周知，在 InnoDB XtraDB, 以及其他一些存储引擎中实现了行级锁。行级锁只在存储引擎层实 现，而 MySQL 服务器层（如有必要，请回顾前文的逻辑架构图）没有实现



### 1.3事务

事务就是一组原 子性的 SQL 查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语旬因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。

**原子性 (atomicity)** 

​		一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，**对一个事务来说，不可能只执行其中的一部分操作**，这就是事务的原子性。

 **一致性 (consistency)** 

​		数据库总是**从一个一致性的状态转换到另外一个一致性的状态**。

**隔离性 (isolation)**

​		通常来说，**一个事务所做的修改在最终提交以前，对其他事务是不可见的**。

**持久性 (durability)**

 		**一且事务提交，则其所做的修改就会永久保存到数据库中**。此时即使系统崩溃，修改的数据也不会丢失。持久性是个有点模糊的概念，因为实际上持久性也分很多 不同的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。而且不可能有能做到 100％的持久性保证的策略

#### 1.3.1隔离级别

**READ UNCOMMITTED （未提交读）**

​		在READ UNCOMMITTED 级别，**事务中的修改即使没有提交，对其他事务也都是可见的**。事务可以读取未提交的数据，这也被称为**脏读 (Dirty Read)** 。这个级别会导致很多问题，从性能上来说， READ UNCOMMITTED 不会比其他的级别好太多，但却缺乏其他级别的很多好处，除非真的有非常必要的理由，在实际应用中一般很少使用。

**READ COMMITTED （提交读）**

​		大多数数据库系统的默认隔离级别都是 READ COMMITTED （但 MySQL 不是）。 READ COMMITTED 满足前面提到的隔离性的简单定义：**一个事务开始时，只能“看见”已经提交的事务所做的修改**。换句话说，**一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的**。这个级别有时候也叫做不可重复读 (nonrepeatable read) ，因为两次执行同样的查询，可能会得到不一样的结果。

**REPEATABLE READ （可重复读）**

​		REPEATABLE READ **解决了脏读的问题**。**该级别保证了在同一个事务中多次读取同样记录的结果是一致的**。但是理论上，可重复读隔离级别还是无法解决另外一个**幻读 (Phantom Read) 的问题**。所谓**幻读，指的是当某个事务在读取某个范围内的记录时， 另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行 (Phantom Row)** 。InnoDB XtraDB 存储引擎通过**多版本并发控制(MVCC, Multiversion Concurrency Control)** 解决了幻读的问题。**可重复读是 MySQL 的默认事务隔离级别。**

**SERIALIZABLE （可串行化）**

​		SERIALIZABLE 是**最高的隔离级别**。它通过**强制事务串行执行**，避免了前面说的幻读的问题。简单来说， **SERIALIZABLE 会在读取的每一行数据上都加锁**，所以**可能导致大量的超时和锁争用的问题**。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有井发的情况下，才考虑采用该级别。

<img src="./screen shot/HighPerformanceMySQL/2.png" alt="image-20210716142726912"  />

补充：

一些典型不一致现象：

**丢失修改**：两个事务对同一数据进行修改，其中一个修改被另一个修改覆盖。

**不可重复读**：在一个事务对一个数据的两次读取之间，另一个事务对此数据进行了修改，导致两次读取读到的数据不一致

**读脏数据**：事务A对数据进行了修改，然后事务B读取了这一数据，但由于一些特殊原因事务A进行了回滚操作，使事务B在这之前读到的数据为脏数据，造成不一致

**幻读**：主要出现在范围查询中。当某个事务在读取某个范围内的记录时， 另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行

#### 1.3.2死锁

**死锁是指两个或者多个事务在同一资源上相互占用，井请求锁定对方占用的资源，从而导致恶性循环**的现象。当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。 多个事务同时锁定同一个资源时，也会产生死锁。

为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统， 比如 InnoDB 存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。这种解决方式很有效，否则死锁会导致出现非常慢的查询。还有一种解决方式，就是**当查询的时间达到锁等待超时的设定后放弃锁请求**，这种方式通常来说不太好。 **InnoDB 目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚（这是相对比较简单的死锁回滚算法）**。

死锁的产生有双重原因：有些是因为真正的数据冲突，这种情况通常 很难避免，但有些则完全是由于存储引擎的实现方式导致的。

死锁发生以后，**只有部分或者完全回滚其中一个事务，才能打破死锁**。对于事务型的系统，这是无法避免的

**补充：**

**活锁**：锁在多个事务之间传递，而有一个或多个事务一直处于等待状态获取不到锁。使用FCFS先来先服务解决。

**死锁诊断**：超时法，等待图法。

**死锁预防**：一次封锁，每个事务在执行前将要使用的全部数据加锁。顺序封锁，预先对数据对象规定一个封锁顺序，所有事务都按照这个顺序实施封锁

**死锁解除**：选择一个处理死锁代价最小的事务将其撤销。

#### 1.3.3事务日志

事务日志可以帮助提高事务的效率。

使用事务日志，**存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘**。

**事务日志采用的是追加的方式**，因此**写日志的操作是磁盘 上一小块区域内的顺序 I/O, 而不像随机 I/O 需要在磁盘的多个地方移动磁头**，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，**内存中被修改的数据在后台可以慢慢地刷回到磁盘**。目前大多数存储引擎都是这样实现的，我们通常称之为**预写式日志** (Write-Ahead Logging) ，修改数据需要**写两次磁盘**。第1次写磁盘：将修改行为持久化到事务日志。第2次写磁盘：将内存中被修改的数据刷回磁盘。

如果数据的修改已经记录到事务日志井持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。

#### 1.3.4MySQL中的事务

**自动提交 (AUTOCOMMIT)**

MySQL 默认采用自动提交 (AUTOCOMMIT) 模式。也就是说，**如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作**。

**InnoDB的锁定**

InnoDB 采用的是**两阶段锁定协议 (two-phase locking protocol)** 。**在事务执行过程中，随时都可以执行锁定，锁只有在执行 COMMIT 或者 ROLLBACK 的时候才会释放，并且所有的锁是在同一时刻被释放**。前面描述的锁定都是隐式锁定， InnoDB 会根据隔离级别在需 要的时候自动加锁。

### 1.4多版本并发控制（MVCC）

MySQL 的大多数事务型存储引擎实现的都不是简单的行级锁。基千提升井发性能的考 虑，它们一般都同时实现了多版本并发控制 (MVCC) 。

InnoDB MVCC, 是通过**在每行记录后面保存两个隐藏的列**来实现的。这两个列，**一 个保存了行的创建时间**，**一个保存行的过期时间（或删除时间）**。当然存储的并不是实际的时间值，而是**系统版本号 (system version number)** 。**每开始一个新的事务，系统版本号都会自动递增**。**事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。**

**SELECT**

InnoDB 会根据以下两个条件检查每行记录： 

a. **InnoDB 只查找版本早于当前事务版本的数据行**（也就是，行的系统版本号小于或等与事务的系统版本号），这样可以**确保事务读取的行，要么是在事务开 始前已经存在的，要么是事务自身插入或者修改过的。**

 b. **行的删除版本要么未定义，要么大于当前事务版本号**。这**可以确保事务读取到的行，在事务开始之前未被删除**。 只有符合上述两个条件的记录，才能返回作为查询结果。

**INSERT** 

InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。

**DELETE**

InnoDB 为删除的每一行保存当前系统版本号作为行删除标识。

**UPDATE**

InnoDB 为插入一行新记录，**保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。**这里相当于删掉旧的，再插入新的

**保存这两个额外系统版本号，使大多数读操作都可以不用加锁**。这样设计使得读数据操作很简单，性能很好，井且也能保证只会读取到符合标准的行。不足之处是每行记录都 需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。

**MVCC 只在 REPEATABLE READ，READ COMMITTED 两个隔离级别下工作**。其他两个隔离 级别都和 MVCC 不兼容注 ，因为 READ UNCOMMITTED 总是读取最新的数据行，而不是符合 当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。

### 1.5MySQL的存储引擎

在文件系统中， MySQL 将每个数据库（也可以称之为 schema) 保存为数据目录下的一个子目录。创建表时， MySQL 会在数据库子目录下创建一个和表同名的．frm 文件保存表的定义。

因为 MySQL 使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感性和具体的平台密切相关。在 Windows 中，大小写是不敏感的；而在类 Unix 中则是敏感的。

#### 1.5.1InnoDB存储引擎

InnoDB 的数据存储在表空间 (tablespace) 中，表空间是由 InnoDB 管理的一个黑盒子， 由一系列的数据文件组成。

**InnoDB 采用 MVCC 来支持高井发，并且实现了四个标准的隔离级别**。其默认级别是 REPEATABLE READ （可重复读），并且**通过间隙锁 (next-key locking) 策略防止幻读的出现**。 **间隙锁使得 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入**。

InnoDB 表是**基于聚簇索引建立的**，我们会在后面的章节详细讨论聚簇索引。 InnoDB 索引结构和 MySQL 的其他存储引擎有很大的不同，**聚簇索引对主键查询有很高的性能**。 **不过它的二级索引 (secondary index, 非主键索引）中必须包含主键列**，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应当尽可 能的小。

InnoDB 内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在 内存中创建 hash 索引以加速读操作的自适应哈希索引 (adaptive hash index) ，以及能够加速插入操作的插入缓冲区 (insert buffer) 等

#### 1.5.2MyISAM存储引擎

**MyISAM 不支持事务和行级锁**，且有一个毫无疑问的缺陷就是**崩溃后无法安全恢复**。。尽管 MyISAM 引擎不支持事务、不支持崩溃后的安全恢复，但它绝不是一无是处。**对于只读的数据，或者表比较小、可以忍受修复 (repair) 操作，则依然可以继续使 MyISAM** （但请**不要默认使用 MylSAM, 而是应当默认使用 lnnoDB**)

**MylSAM 特性**

加锁与并发

​		**MyISAM 对整张表加锁，而不是针对行**。**读取时会对需要读到的所有表加共享锁， 写入时则对表加排他锁**。但是在表有读取查询的同时，也可以往表中插入新的记录 （这被称为井发插入， CONCURRENT INSERT)

......

MylSAM 性能

MyISAM 引擎设计简单，数据以紧密格式存储，所以在某些场景下的性能很好。 MyISAM 有一些服务器级别的性能扩展限制，比如对索引键缓冲区 (key cache) Mutex 锁， MariaDB 基于段 (segment) 的索引键缓冲区机制来避免该问题。但 MyISAM 最典型的性能问题还是表锁的问题，如果你发现所有的查询都长期处千 “Locked" 状态， 那么毫无疑问表锁就是罪魁祸首。

#### 1.5.5选择合适的引擎

这么多存储引擎，我们怎么选择？**大部分情况下， InnoDB 都是正确的选择**，所以 Oracle MySQL 5.5 版本时终千将 InnoDB 作为默认的存储引擎了。对于如何选择存储引擎， 可以简单地归纳为一句话：“**除非需要用到某些 InnoDB 不具备的特性，并且没有其他办法可以替代，否则都应该优先选择 InnoDB 引擎**＂。例如，如果要用到全文索引，建议优先考虑 InnoDB 加上 Sphinx 的组合，而不是使用支持全文索引的 MyISAM 。当然，如果不需要用到 InnoDB 的特性，同时其他引擎的特性能够更好地满足需求，也可以考虑一 下其他存储引擎。

举个例子，如果不在乎可扩展能力和井发能力，也不在乎崩溃后的数 据丢失问题，却对 InnoDB 的空间占用过多比较敏感，这种场合下选择 MylSAM 就比较 合适。 **除非万不得已，否则建议不要混合使用多种存储引擎，否则可能带来一系列复杂的问题， 以及一些潜在的 bug 和边界问题**。存储引擎层和服务器层的交互已经比较复杂，更不用 说混合多个存储引擎了。至少，混合存储对一致性备份和服务器参数配置都带来了一些 困难



## 4.Schema与数据类型优化

良好的逻辑设计和物理设计是高性能的基石，应该根据系统将要执行的查询语句来设计 schema, 这往往需要权衡各种因素。

### 4.1选择优化的数据类型

**更小的通常更好**

​		一般情况下，**应该尽最使用可以正确存储数据的最小数据类型** 。**更小的数据类型通常更快，因为它们占用更少的磁盘、内存和 CPU 缓存**，**并且处理时需要的 CPU周期也更少**。 **但是要确保没有低估需要存储的值的范围**，因为**在 schema 中的多个地方增加数据类型的范围是一个非常耗时和痛苦的操作**。如果无法确定哪个数据类型是最好的，就选择你认为不会超过范围的最小类型。（如果系统不是很忙或者存储的数据量不多， 或者是在可以轻易修改设计的早期阶段，那之后修改数据类型也比较容易）。

**简单就好**

​		**简单数据类型的操作通常需要更少的 CPU 周期**。例如，整型比字符操作代价更低， 因为字符集和校对规则（排序规则）使字符比较比整型比较更复杂。这里有两个例子： 一个是应该使用 MySQL 内建的类型注而不是字符串来存储日期和时间，另外一个 是应该用整型存储 IP 地址。

**尽量避免 NULL**

​		很多表都包含可为 NULL （空值）的列，即使应用程序并不需要保存 NULL 也是如此， 这是因为可为 NULL是列的默认属性注。**通常情况下最好指定列为 NOT NULL, 除非真的需要存储 NULL 值**。

​		如果查询中包含可为 NULL 的列，**对 MySQL 来说更难优化，因为可为 NULL 的列使得索引、索引统计和值比较都更复杂**。可为 NULL 的列会使用更多的存储空间，在 MySQL 里也需要特殊处理。当可为 NULL 的列被索引时，每个索引记录需要一个额外的字节，在 MyISAM 里甚至还可能导致固定大小的索引（例如只有一个整数列的 索引）变成可变大小的索引。



在为列选择数据类型时**，第一步需要确定合适的大类型：数字、字符串、时间**等。**下一步是选择具体类型**。很多 MySQL 的数据类型可以存储相同类型的数据，只是存储的长度和范围不一样、允许的精度不同，或者需要的物理空间（磁盘和内存空间）不同。

#### 4.1.1整数类型

有两种类型的数字：**整数 (whole number)** 和**实数 (real number)** 。如果存储整数，可 以使用这几种整数类型： **TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT**。分别使用 8, 16, 24, 32, 64 位存储空间。它们可以存储的值的范围从－ N“ 2(N 1)_1, 其中 存储空间的位数。

 **整数类型有可选的 UNSIGNED 属性，表示不允许负值，这大致可以使正数的上限提高一倍**。 例如 TINYINT. UNSIGNED 可以存储的范围是 - 255, TINYINT 的存储范围是－l28 ~  127 有符号和无符号类型使用相同的存储空间，并具有相同的性能，因此可以根据实际情况 选择合适的类型。

**有符号和无符号类型使用相同的存储空间，并具有相同的性能**，因此可以根据实际情况 选择合适的类型。

#### 4.1.2实数类型

实数是带有小数部分的数字。然而，它们不只是为了存储小数部分，也可以使用 DECIMAL 存储比 BIGINT 还大的整数。 MySQL 既支持精确类型，也支持不精确类型。

#### 4.1.3字符串类型

**VARCHAR**

VARCHAR 类型**用于存储可变长字符串**，是最常见的字符串数据类型。它**比定长类型更节省空间**，因为**它仅使用必要的空间**（例如，越短的字符串使用越少的空间）。

**VARCHAR 需要使用1或2个额外字节记录字符串的长度**：如果列的最大长度小千或 等于 255 字节，则只使用 个字节表示，否则使用 个字节。

VARCHAR 节省了存储空间，所以对性能也有帮助。但是，**由于行是变长的，在 UPDATE 时可能使行变得比原来更长，这就导致需要做额外的工作**。例如， MyISAM 会将行拆成不同的片段存储， InnoDB 则需要分裂页来使行可以放进页内。其他一些存储引擎也许从不在原数据位置更新数据。**可能会产生碎片**。

下面这些情况下使用 VARCHAR 是合适的：**字符串列的最大长度比平均长度大很多**，**列的更新很少，所以碎片不是问题**，使用了像 UTF-8 这样复杂的字符集，每个字符 都使用不同的字节数进行存储。



**CHAR**

**CHAR 类型是定长的**： **MySQL 总是根据定义的字符串长度分配足够的空间**。当存储 CHAR 值时， MySQL **会删除所有的末尾空格**。

**CHAR 适合存储很短的字符串**，或者**所有值都接近同一个长度**。例如， CHAR非常适 合存储密码的 MD5 值，因为这是一个定长的值。**对于经常变更的数据， CHAR 也比 VARCHAR 更好，因为定长的 CHAR 类型不容易产生碎片**。对于非常短的列， CHAR VARCHAR 在存储空间上也更有效率。例如用 CHAR(l) 来存储只有 的值，如果 采用单字节字符集只需要一个字节，但是 VARCHAR(l) 却需要两个字节，因为还有一个记录长度的额外字节。

数据如何存储取决于存储引擎，**并非所有的存储引擎都会按照相同的方式处理定长和变长的字符串**。 



**BLOB和TEXT类型**

BLOB TEXT 都是**为存储很大的数据而设计的字符串数据类型**，分别采用**二进制**和**字符方式**存储。

BLOB TEXT 家族之间仅有的不同是 **BLOB 类型存储的是二进制数据，没有排序规则或字符集，而 TEXT 类型有字符集和排序规则**。



枚举ENUM

....



#### 4.1.4日期和时间类型

**DATEATIME**

​		这个类型能保存大范围的值，从 1001 年到 9999 年，精度为秒。它把日期和时间封装到格式为 YYYYMMDDHHMMSS 的整数中，与时区无关。使用8个字节的存储空间。

**TIMESTAMP**

​		就像它的名字一样， TIMETAMP 类型保存了从 1970年1月1日午夜（格林尼治标准 时间）以来的秒数，它和 UNIX 时间戳相同。TIMESTAMP 只使用4个字节的存储空间， 因此它的范围比 DATETIME 小得多：只能表示从 1970 年到 2038 年。 MySQL 提供了 FROM_UNIXTIME( ）函数把 Unix 时间戳转换为日期，井提供了 UNIX_TIMESTAMP( ）函 数把日期转换为 Unix 时间戳。

除了特殊行为之外，通常也应该尽量使用 TIMESTAMP, 因为它比 DATETIME 空间效率更高。



#### 4.1.6选择标识符 (identifier)

为标识列 (identifier column) 选择合适的数据类型非常重要。一般来说更有可能用标识 列与其他值进行比较（例如，在关联操作中），或者通过标识列寻找其他列。标识列也可能在另外的表中作为外键使用，所以为标识列选择数据类型时，应该选择跟关联表中 的对应列一样的类型

**整数类型**

​	整数通常是标识列最好的选择，因为它们**很快并且可以使用 AUTO_INCREMENT**

**ENUM SET 类型**

​		对于标识列来说， EMUM SET 类型通常是一个糟糕的选择，尽管对某些只包含固定 状态或者类型的静态”定义表”来说可能是没有问题的。 ENUM SET 列适合存储固 定信息，例如有序的状态、产品类型、人的性别。

**字符串类型**

​		如果可能，应该避免使用字符串类型作为标识列，因为**它们很消耗空间，并且通常比数字类型慢**。尤其是在 MyISAM 表里使用字符串作为标识列时要特别小心。 MylSAM 默认对字符串使用压缩索引，这会导致查询慢得多。

​		对千完全”随机”的字符串也需要多加注意，例如 MDS( ）、 SHAl( ）或者 UUID( ）产生 的字符串。**这些函数生成的新值会任意分布在很大的空间内**，这会导致 INSERT 以及 一些 SELECT 语句变得很慢

因为**插入值会随机地写到索引的不同位置**，所以使得 INSERT 语句更慢。这会导致页分裂、磁盘随机访问，以及对千聚簇存储引擎产生聚簇索引碎片。

SELECT 语句会变得更慢，因为**逻辑上相邻的行会分布在磁盘和内存的不同地方**。

**随机值导致缓存对所有类型的查询语句效果都很差**，因为会使得缓存赖以工作的**访问局部性原理失效**。如果整个数据集都一样的“热”，那么缓存任何一部分特定数据到内存都没有好处；如果工作集比内存大，缓存将会有很多刷新和不命中。



### 4.2MySQL schema 设计中的陷阱

**太多的列**

...

**太多的关联**

所谓的“实体－属性－值”(EAV) 设计模式是一个常见的糟糕设计模式，尤其是在 MySQL 下不能靠谱地工作。。一个粗略的经验法则，如果希望查询执行得快速且井发性好，单个查询最好在 12 个表以内做关联。

....



### 4.3范式与反范式

对千任何给定的数据通常都有很多种表示方法，从完全的范式化到完全的反范式化，以及两者的折中。**在范式化的数据库中，每个事实数据会出现并且只出现一次**。相反，**在反范式化的数据库中，信息是冗余的，可能会存储在多个地方**。

#### 4.3.1范式的优点和缺点

当为性能问题而寻求帮助时，经常会被建议对 schema 进行范式化设计，尤其是写密集的场景。

- 范式化的更新操作通常比反范式化要快。
- 当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据。
- 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快。
- 很少有多余的数据意味着检索列表数据时更少需要 DISTINCT 或者 GROUP BY 语句。

范式化设计的 schema的**缺点是通常需要关联**。稍微复杂一些的查询语句在符合范式的 schema 上都可能需要至少一次关联，也许更多。**这不但代价昂贵，也可能使一些索引策略无效**。例如，范式化可能将列存放在不同的表中，而这些列如果在一个表中本可以属 千同一个索引。

#### 4.3.2反范式的优点

反范式化的 schema 因为所有数据都在一张表中，可以很好地避免关联。

如果不需要关联表，则对大部分查询最差的情况——即使表没有使用索引——是全表扫 描。当数据比内存大时这可能比关联要快得多，因为这样避免了随机 I/0

#### **4.3.3混用范式化和反范式化**

完全的范式化和完全的反范式化 schema 都是实验室里才有的东西：在真实世界中很少会这么极端地使用。在实际应用中经常需要混用，可能使用部分范式化的 schema 、缓存表，以及其他技巧。

最常见的反范式化数据的方法是**复制或者缓存**，**在不同的表中存储相同的特定列**。



### 4.4缓存表与汇总表

#### 4.4.2 计数器表

如果应用在表中保存计数器，则在更新计数器时可能碰到井发问题。这会使得这些事务只能串行执行。要获得更高的并发更新性能，也可以**将计数器保存在多行中，每次随机选择一行进行更新**。在统计时使用聚合查询求和即可



### 4.5 加快 ALTER TABLE 操作的速度

一般而言，**大部分 ALTER TABLE 操作将导致 MySQL 服务中断**。

对常见的场景，能使用的技巧只有两种：

一种是**先在一台不提供服务的机器上执行 ALTER TABLE 操作，然后和提供服务的主库进行切换**；

另外一种技巧是“**影子拷贝**＂。影子拷贝的技巧是**用要求的表结构创建一张和源表无关的新表**，**然后通过重命名和删表操作交换两张表**。

#### 4.5.2 快速创建 MylSAM 索引

为了高效地载入数据到 MyISAM 表中，有一个常用的技巧是先禁用索引、载入数据，然 后重新启用索引



## 5创建高性能的索引

**索引对于良好的性能非常关键**。尤其是**当表中的数据量越来越大时，索引对性能的影响愈发重要**。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但**当数据址逐渐增大时，性能则会急剧下降**。

### **5.1索引基础**

在MySQL 中，**存储引擎用类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行**。

索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为 **MySQL 只能高效地使用索引的最左前缀列**。

#### 5.1.1索引的类型

在 MySQL 中，索引是在存储引擎层而不是服务器层实现的

**B-Tree 索引**

存储引擎以不同的方式使用 B-Tree 索引，性能也各有不同，各有优劣。例如， **MyISAM 使用前缀压缩技术使得索引更小**，但 **lnnoDB 则按照原数据格式进行存储**。再如 MyISAM 索引通过数据的物理位置引用被索引的行，而 InnoDB 则根据主键引用被索引 的行。

<img src="./screen shot/HighPerformanceMySQL/3.png" alt="image-20210717174235917"  />

B-Tree 索引能够加快访问数据的速度，因为**存储引擎不再需要进行全表扫描来获取需要的数据**，取而代之的是**从索引的根节点（图示井未画出）开始进行搜索**。根节点的槽中 存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，**这些指针实际上定义了子节点页中值的上限和下限**。最终存储引擎**要么是找到对应的值，要么该记录不存在**。

B-Tree 对索引列是**顺序组织存储**的，所以很**适合查找范围数据**

<img src="./screen shot/HighPerformanceMySQL/4.png" alt="image-20210720145926470"  />

<img src="./screen shot/HighPerformanceMySQL/5.png" alt="image-20210720145938152"  />

索引对多个值进行排序的依据是 CREATE TABLE 语句中定义索引时列的顺序。

可以使用 B-Tree 索引的查询类型。 B-Tree 索引适用于**全键值**、**键值范围**或**键前缀查找**。 其中**键前缀查找只适用千根据最左前缀的查找**。

**全值匹配**

​		全值匹配指的是**和索引中的所有列进行匹配**，例如前面提到的索引可用于查找姓名为Cuba Allen 、出生于1960-01-01 的人。

**匹配最左前缀**

​		前面提到的索引可用千查找所有姓为 Allen 的人，即**只使用索引的第一列**。

**匹配列前缀**

​		也**可以只匹配某一列的值的开头部分**。例如前面提到的索引可用于查找所有以J开头的姓的人。这里也只使用了索引的第一列。

**匹配范围值**

​		例如前面提到的索引可用于查找姓在Allen和Barrymore之间的人。这里也只使用了索引的第一列。

**精确匹配某一列并范围匹配另外一列**

​		前面提到的索引也可用千查找所有姓为 Allen, 井且名字是字母K开头（比如 Kim Karl 等）的人。即**第一列 last_name 全匹配，第二列 first_name 范围匹配**。

**只访问索引的查询**

​		B-Tree 通常可以支持“**只访问索引的查询**＂，即**查询只需要访问索引，而无须访问数据行**。后面我们将单独讨论这种**覆盖索引**的优化。



因为索引树中的节点是有序的，所以除了按值查找之外，**索引还可以用于查询中的 ORDER BY 操作**（按顺序查找）。一般来说，如果 B-Tree 可以按照某种方式查找到值，那么也可以按照这种方式用于排序。



**B-Tree 索引的限制**：

- 如果不是按照索引的最左列开始查找，则无法使用索引。
- 不能跳过索引中的列。也就是说，前面所述的索引无法用千查找姓为 Smith 并且在 某个特定日期出生的人。如果不指定名 (first_name) ，则 MySQL 只能使用索引的 第一列。
- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。



**哈希索引**

哈希索引 (hash index) **基于哈希表实现**，**只有精确匹配索引所有列的查询才有效**。对每一行数据，存储引擎都会对所有的索引列计算一个哈希码 (hash code) ，哈希码是 一个较小的值，并且不同键值的行计算出来的哈希码也不一样。**哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针**。

MySQL 中，**只有 Memory 引擎显式支持哈希索引**。这也是 Memory 引擎表的默认索引类型。

因为**索引自身只需存储对应的哈希值，所以索引的结构十分紧凑**，这也让**哈希索引查找的速度非常快**。



**哈希索的限制：**

- **哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行**。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的 影响并不明显。
- 哈希索引**数据并不是按照索引值顺序存储的**，所以也就**无法用于排序**。
- 哈希索引也**不支持部分索引列匹配查**找，因为**哈希索引始终是使用索引列的全部内容来计算哈希值的**。例如，在数据列 (A,B) 上建立哈希索引，如果查询只有数据列 A, 则无法使用该索引。
- **哈希索引只支持等值比较查询，包括＝、 IN( ）、<:=>**（注意＜＞和<=>是不同的操作）。 也不支持任何范围查询，例如 WHERE price> 100
- **访问哈希索引的数据非常快，除非有很多哈希冲突**（不同的索引列值却有相同的哈希值）。**当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较**，直到找到所有符合条件的行。
- **如果哈希冲突很多的话，一些索引维护操作的代价也会很高**。例如，如果在某个选择性很低（哈希冲突很多）的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用，**冲突越多， 代价越大**。



因为这些限制，哈希索引只适用某些特定的场合。而一旦适合哈希索引，则它带来的性能提升将非常显著

### 5.2索引的优点

索引可以让服务器**快速地定位到表的指定位置**。

最常见的 B-Tree 索引，按照顺序存储数据，所以 MySQL 可以用来做 ORDER BY GROUP BY 操作。因为数据是有序的，所以 B-Tree 也就会将相关的列值都存储在一起。最后， 因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。

三个优点：

- 索引大大**减少了服务器需要扫描的数据量**。
- 索引可以**帮助服务器避免排序和临时表**。
- 索引可以**将随机 I/O 变为顺序 I/O**



索引并不总是最好的工具。总的来说，**只有当索引帮助存储引擘快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的**。对于非常小的表，大部分情 况下简单的全表扫描更高效。对于中到大型的表，索引就非常有效。但对于特大型 的表，建立和使用索引的代价将随之增长。



### 5.3高性能的索引策略

正确地创建和使用索引是实现高性能查询的基础。

#### 5.3.1 独立的列

**如果查询中的列不是独立的，则 MySQL 就不会使用索引**。“独立的列”是指**索引列不能是表达式的一部分，也不能是函数的参数**。

例如，下面这个查询无法使用 actor_id 列的索引：

```sql
mysql> SELECT actor_id FRO,.,sakila.actor WHERE actor_id + 1 = s; 
```

凭肉眼很容易看出 WHERE 中的表达式其实等价千 actor id = 4, 但是 MySQL 无法自动解析这个方程式。这完全是用户行为。我们应该养成简化 WHERE 条件的习惯，**始终将索引列单独放在比较符号的一侧**。



#### 5.3.2前缀索引和索引选择性

通常**可以索引开始的部分字符**，这样**可以大大节约索引空间**，从而提高索引效率。但这样也会降低索引的选择性。索引的选择性越高则查询效率越高，因为**选择性高的索引可以让 MySQL 在查找时过滤掉更多的行**。 **唯一索引的选择性是 1, 这是最好的索引选择性，性能也是最好的**。

诀窍在于**要选择足够长的前缀以保证较高的选择性，同时又不能太长**（以便节约空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引整个列。换句话说，前缀的“基数”应该接近于完整列的“基数”。



前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有其缺点： **MySQL 法使用前缀索引做 ORDER BY GROUP BY, 也无法使用前缀索引做覆盖扫描**。



#### 5.3.3多列索引

在多个列上建立独立的单列索引大部分情况下并不能提高 MySQL 的查询性能。

索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建得很糟糕



#### 5.3.4 选择合适的索引列顺序

在一个多列 B-Tree 索引中，**索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列**，等等。所以，**索引可以按照升序或者降序进行扫描**。

对于如何选择索引的列顺序有一个经验法则：**将选择性最高的列放到索引最前列**。这个 建议有用吗？在某些场景可能有帮助，但**通常不如避免随机 IO和排序那么重要**，考虑问题需要更全面。

**当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的**。这时候索引的作用只是用千优化 WHERE 条件的查找。然而，性能不只是依赖千所有索引列的选择性（整体基数），也和查询条件的具体值有关，也就是**和值的分布有关**。这和前面介绍的选择前缀的长度需要考虑的地方一样。 可能需要**根据那些运行频率最高的查询来调整索引列的顺序，让这种情况下索引的选择性最高**。



#### 5.3.5聚簇索引

聚簇索引并不是一种单独的索引类型，而**是一种数据存储方式**。InnoDB 的聚簇索引实际上**在同一个结构中保存了 B-Tree 索引和数据行**。

当表有聚簇索引时，**它的数据行实际上存放在索引的叶子页** (leaf page) 中。因为无法同时把数据行存放在两个不同 的地方，所以**一个表只能有一个聚簇索引**。

<img src="./screen shot/HighPerformanceMySQL/6.png" alt="image-20210720170948573"  />

InnoDB 将**通过主键聚集数据**，这也就是说图 5-3 中的”被索引的列”就是主键列。

聚簇索引一些重要优点：

- **可以把相关数据保存在一起**。例如实现电子邮箱时，可以根据用户 ID 来聚集数据， 这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O，即减少I/O
- **数据访问更快**。聚簇索引将索引和数据保存在同一个 B-Tree 中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。
- 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

一些缺点：

- 聚簇数据最大限度地提高了 I/0 密集型应用的性能，**但如果数据全部都放在内存中， 则访问的顺序就没那么重要了，聚簇索引也就没什么优势了**。
- **插入速度严重依赖千插入顺序**。**按照主键的顺序插入是加载数据到 InnoDB 表中速度最快的方式**。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用 OPTIMIZE TABLE 命令重新组织一下表。
- **更新聚簇索引列的代价很高，因为会强制 InnoDB 将每个被更新的行移动到新的位置**。
- 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂 (page split) 的问题。**当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行**，这就是一次页分裂操作。 **页分裂会导致表占用更多的磁盘空间**。
- **聚簇索引可能导致全表扫描变慢**，尤其是行比较稀疏，或者由千页分裂导致数据存 储不连续的时候。
- 二级索引（非聚簇索引）可能比想象的要更大，因为在**二级索引的叶子节点包含了引用行的主键列**。
- **二级索引访问需要两次索引查找**，而不是一次。

**二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值**。这意味着通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。这里做了重复的工作：**两次 B-Tree 查找而不是一次**



使用主键值当作指针会让二级索引占用更多的空间，换来的好处是， **InnoDB 在移动行时无须更新二 级索引中的这个”指针”**。



**在lnnoDB 表中按主键顺序插入行**

如果正在使用 InnoDB 表井且没有什么数据需要聚集，那么**可以定义一个代理键 (surrogate key) 作为主键，这种主键的数据应该和应用无关**，最简单的方法是**使用 AUTO_INCREMENT 自增列**。这样**可以保证数据行是按顺序写入**，对千根据主键做关联操作的性能也会更好。

**最好避免随机的（不连续且值的分布范围非常大）聚簇索引**，特别是对千 1/0 密集型的 应用

因为新行的主键值不一定比之前插入的大，所以 **lnnoDB 无法简单地总是把新行插入到索引的最后，而是需要为新的行寻找合适的位置——通常是已有数据的中间位置——并且分配空间**。这会增加很多的额外工作，并导致数据分布不够优化。

因此，使用 InnoDB 时应该**尽可能地按主键顺序插入数据**，并且**尽可能地使用单调增加的聚簇键的值来插入新行**。



#### 5.3.6覆盖索引

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为＂覆盖索引”。

优点：

- 索引条目通常远小于数据行大小，所以**如果只需要读取索引，那 MySQL 就会极大地减少数据访问量**
- 因为索引是按照列值顺序存储的（至少在单个页内是如此），所以对于I/0 密集型的范围查询会比随机从磁盘读取每一行数据的 I/O 要少得多。
- 由于 InnoDB 的聚簇索引，覆盖索引对 lnnoDB 表特别有用。 InnoDB 的二级索引在叶子节点中保存了行的主键值，所以**如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询**。

**不是所有类型的索引都可以成为覆盖索引**。**覆盖索引必须要存储索引列的值**，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以 **MySQL 只能使用 B-Tree 索引做 覆盖索引**



#### 5.3.7使用索引扫描来做排序

MySQL 有两种方式可以生成有序的结果：通过**排序操作**或者**按索引顺序扫描**。

MySQL 可以使用同一个索引既满足排序，又用于查找行。因此，如果可能，设计索引时应该尽可能地同时满足这两种任务，这样是最好的。

只有**当索引的列顺序和 ORDER BY 子句的顺序完全一致，井且所有列的排序方向（倒序或正序）都一样**时， MySQL 才能够使用索引来对结果做排序。ORDER BY 子句和查找型查询的限制是一样的：**需要满足索引的最左前缀的要求**；否则， MySQL 都需要执行排序操作，而无法利用索引排序。



#### 5.3.8压缩（前缀压缩）索引

MyISAM 使用**前缀压缩**来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大地提高性能。时间换空间



#### 5.3.9 冗余和重复索引

MySQL 允许在相同列上创建多个索引。

重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。应该避免这样创建 重复索引，发现以后也应该立即移除。

如果创建了索引 (A, B) ，再创建索引 (A) 就是冗余索引， 因为这只是前一个索引的前缀索引。创建另一个索引的前缀作为索引是冗余的。大多数情况下都不需要冗余索引，**应该尽量扩展已有的索引而不是创建新索引**。

一般来说，增加新索引将会导致 INSERT UPDATE DELETE 等操作的速度变慢，特别是当新增索引后导致达到了内存瓶颈的时候。



#### 5.3.10 未使用的索引

除了冗余索引和重复索引，可能还会有一些服务器永远不用的索引。这样的索引完全是累赘，建议考虑删除。



#### 5.3.11 索引和锁

**索引可以让查询锁定更少的行**。如果你的查询从不访问那些不需要的行，那么就会锁定更少的行，从两个方面来看这对性能都有好处。

InnoDB 只有在访问行的时候才会对其加锁，而**索引能够减少 InnoDB 访问的行数，从而减少锁的数量**

即使使用了索引， InnoDB 也可能锁住一些不需要的数据。如果不能使用索引查找和锁定行的话问题可能会更糟糕， MySQL 会做全表扫描并锁住所有的行，而不管是不是需要。



## 6.查询性能优化

### 6.3 重构查询的方式

#### 6.3.1 一个复杂查询还是多个简单查询

设计查询的时候一个需要考虑的重要问题是，是否需要将一个复杂的查询分成多个简单的查询。

#### 6.3.2 切分查询

有时候对千一个大查询我们需要“分而治之”，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。

删除旧的数据就是一个很好的例子。定期地清除大量数据时，如果用一个大的语句一次 性完成的话，则可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。**将一个大的 DELETE 语句切分成多个较小的查询可以尽可能小地影响 MySQL 性能**，同时还可以减少 MySQL 复制的延迟。

<img src="./screen shot/HighPerformanceMySQL/7.png" alt="image-20210720181738041"  />

#### 6.3.3分解关联查询

很多高性能的应用都会对关联查询进行分解。简单地，可以对每一个表进行一次单表查 询，然后将结果在应用程序中进行关联。

<img src="./screen shot/HighPerformanceMySQL/8.png" alt="image-20210720181916232"  />

在很多场景下，通过重构查询将关联放到应用程序中将会更加高效



### 6.4查询执行的基础

#### 6.4.1 MySQL 客户端／服务器通信协议

MySQL 客户端和服务器之间的通信协议是“**半双工**”的，这意味着， 在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。所以，我们**无法也无须将一个消息切成小块独立来发送**。

一个明显的限制是，这意味着**没法进行流量控制**。一且一端开始发生消息，另一端要接收完整个消息才 能响应它。



#### 6.4.2查询缓存

在解析一个查询语句之前，如果查询缓存是打开的，那么 **MySQL 会优先检查这个查询是否命中查询缓存中的数据**。这个检查是通过一个对大小写敏感的哈希查找实现的。

如果当前的查询恰好命中了查询缓存，那么**在返回查询结果之前 MySQL 会检查一次用户权限**。这仍然是无须解析查询 SQL 语句的，因为在查询缓存中已经存放了当前查询需要访问的表信息。如果权限没有问题， MySQL 会跳过所有其他阶段，直接从缓存中拿到结果并返回给客户端。**这种情况下，查询不会被解析，不用生成执行计划，不会被执行**。



#### 6.4.3查询优化处理

**查询优化器**

**MySQL 使用基于成本的优化器**，它将**尝试预测一个查询使用某种执行计划时的成本， 并选择其中成本最小的一个**。

有很多种原因会导致 MySQL 优化器选择错误的执行计划：

- **统计信息不准确**。 MySQL 依赖存储引擎提供的统计信息来评估成本，但是有的存储 引擎提供的信息是准确的，有的偏差可能非常大。
- **执行计划中的成本估算不等同于实际执行的成本**。所以即使统计信息精准，优化器 给出的执行计划也可能不是最优的

...

优化策略可以简单地分为两种，一种是静态优化，一种是动态优化。静态优化可以直接对解析树进行分析，井完成优化。可以认为这是一种“编译时优化”。

动态优化则和查询的上下文有关，也可能和很多其他因素有关。，可以认为这是“运行时优化”。

...



**排序优化**

无论如何排序都是一个成本很高的操作，所以从性能角度考虑，**应尽可能避免排序或者尽可能避免对大量数据进行排序**。

**当不能使用索引生成排序结果的时候， MySQL 需要自已进行排序**，如果数据最小则在内存中进行，如果数据量大则需要使用磁盘，不过 MySQL 将这个过程统一称为**文件排序** (filesort)

如果需要**排序的数据量小于＂排序缓冲区 ”,MySQL 使用内存进行“快速排序”操作**。如果内存不够排序，那么 **MySQL 会先将数据分块，对每个独立的块使用“快速排序”进行排序，并将各个块的排序结果存放在磁盘上，然后将各个排好序的块进行合并 (merge)** ，最后返回排序结果。



**两次传输排序（旧版本使用）**：

**读取行指针和需要排序的字段，对其进行排序**，然后再根据排序结果读取所需要的数据行。

优点：在排序的时候存储尽可能少的数据，这就**让＂排序缓冲区”中可能容纳尽可能多的行数**进行排序。

缺点：这**需要进行两次数据传输**，即需要从数据表中读取两次数据，第二次读取数据的时候，因为是读取排序列进行排序后的所有记录，这**会产生大量的随机 I/O**, 所以两次数据传输的成本非常高



**单次传输排序（新版本使用）**：

先读取查询所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果。

优点：不再需要从数据表中读取两次数据，对I/O密集型的应用，这样做的效率高了很多。**这个算法只需要一次顺序 I/O 读取所有的数据，而无须任何的随机 I/O** 。

缺点：果需要返回的列非常多、非常大，会**额外占用大量的空**间，而这些列对排序操作本 身来说是没有任何作用的



