# Redis

《Redis设计与实现》的笔记

https://blog.csdn.net/qq_41699100/article/details/86102235

## 1 特性

- 通过哨兵和复制机制实现高可用
- 支持事务
- Redis是单进程单线程的，Redis**利用队列技术将并发访问变为串行访问**，消除了传统数据库串行控制的开销。
- Redis的瓶颈最有可能是机器内存或者网络带宽，而不是CPU，因此采用单线程
- **数据在内存中，速度快**。单点TPS达到8万/秒

TPS :是TransactionsPerSecond的缩写，也就是**事务数/秒**。它是软件测试结果的测量单位。一个事务是指**一个客户机向服务器发送请求然后服务器做出反应的过程**。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。



## 2 数据结构

支持多种类型的数据结构

1.string：最基本的数据类型，二进制安全的字符串，最大512M。

2.list：按照添加顺序保持顺序的字符串列表。

3.set：无序的字符串集合，不存在重复的元素。

4.sorted set：已排序的字符串集合。

5.hash：key-value对的一种集合。



## 3 持久化

### 3.1 RDB

​		RDB持久化方式对服务器所有数据库中的所有键值对数据进行保存。**默认开启**，会按照配置的指定时间将内存中的数据快照到磁盘中，创建一个dump.rdb文件，Redis启动时再恢复到内存中

​		Redis会单独创建fork()一个子进程，**将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中**，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。

​		每次快照持久化都会将主进程的数据库数据复制一遍，**导致内存开销加倍**，若此时内存不足，则会阻塞服务器运行，直到复制结束释放内存；都会将内存数据完整写入磁盘一次，**所以如果数据量大的话，而且写操作频繁，必然会引起大量的磁盘I/O操作，严重影响性能**，并且最后一次持久化后的数据可能会丢失



### 3.2 AOF

​		AOF持久化通过**保存Redis服务器所执行的写命令日志来记录数据库状态**，只需追加文件但不改写文件。在还原时服务器只需要读入并重新执行一遍AOF文件中保存的写命令，就可以还原服务器关闭前的数据库状态。而且还有AOF文件后台重写功能，产生一个更小的新的AOF文件保存数据库状态

​		重写功能：当日志文件大到一定程度的时候，会**fork出一个新进程来遍历进程内存中的数据，每条记录对应一条set语句，写到临时文件中**，然后再替换到旧的日志文件（类似rdb的操作方式）。这样新文件的大小就会减小



当两种持久化方式同时开启时，数据恢复Redis会优先选择AOF恢复,因为**在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整**.



## 4 哨兵（Sentinel）模式

​		Sentinel是Redis的高可用性解决方案：**由一个或多个哨兵实例组成的哨兵系统可以监视任意多个主服务器**，以及这些主服务器属下的所有从服务器，并在被监控的主服务器下线时，自动将下线主服务器属下的某个服务器升级为新的主服务器。

### 4.1 下线检测

​		在默认情况下， 哨兵会以每秒一次的频率向所有与它创建了命令连接的实例（包括 主服务器、从服务器、其他 Sentinel 在内）发送 PING 命令，井通过实例返回的 PING 命令回复来判断实例是否在线。**在达到下线时长后会将实例标记为主观下线**。

​		当Sentinel 将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线了，它会**向同样监视这一主服务器的其他 Sentinel 进行询问**，看它们是否也认为主服务器已经进入了下线状态（可以是主观下线或者客观下线）。**当 Sentinel 从其他 Sentinel 那里接收到足够数量的已下线判断之后， Sentinel 就会将从服务器判定为客观下线，并对主服务器执行故障转移操作**。即主观下线投票



### 4.2 领头哨兵选举

​		当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个 Sentinel 会进行协商，**选举出一个领头 Sentinel, 并由领头 Sentinel 对下线主服务器执行故障转移操作**。

​		领头哨兵选举规则和方法即raft协议的选举实现。



### 4.3 故障转移

- 首先， Sentinel 系统会**挑选原主服务器属下的其中一个从服务器，井将这个被选中的从服务器升级为新的主服务器**。
- 之后， Sentinel 系统会向原主服务器属下的所有从服务器发送新的复制指令，**让它们成为新的主服务器的从服务器**，当所有从服务器都开始复制新的主服务器时，故障 转移操作执行完毕。
- 另外， Sentinel 还会继续监视已下线的原主服务器 , **并在它重新上线时，将它设置为新的主服务器的从服务器**。



## 5 集群模式

​		Redis 集群是 Redis 提供的分布式数据库方案，集群通过分片 (sharding) 来进行数据共享，**并提供复制和故障转移功能**。

### 5.1 故障检测

​		集群中的**每个节点都会定期地向集群中的其他节点发送 PING 消息**，以此来检测对方是否在线，如果接收 PING 消息的节点没有在规定的时间内，向发送 PING 消息的节点返 PONG 消息，那么发送 PING 消息的节点就会将接收 PING 消息的节点**标记为疑似下线**

​		

### 5.2 故障转移

​		**当一个从节点发现自己正在复制的主节点进人了已下线状态时，从节点将开始对下线主节点进行故障转移**，以下是故障转移的执行步骤：

- 复制下线主节点的所有从节点里面，**会有一个从节点被选中**。
- 被选中的从节点会执行 SLAVEOF no one 命令，**成为新的主节点**。
- **新的主节点会撤销所有对巳下线主节点的槽指派，并将这些槽全部指派给自己**。
- **新的主节点向集群广播一条 PONG 消息**，这条 PONG 消息可以让集群中的其他节点 立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由己下线节点 责处理的槽。
- **新的主节点开始接收和自己负责处理的槽有关的命令请求**，故障转移完成。

新主服务器选举规则和方法即raft协议的选举实现。



## 6 事务

​		事务提供了一种**将多个命令请求打包，然后一次性、按顺序地执行多个命令**的机制，并且在事务执行期间，服务器**不会中断事务而改去执行其他客户端的命令请求**，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。

### 6.1 事务的ACID性质

#### 6.1.1 原子性

​		事务具有原子性指的是，**数据库将事务中的多个操作当作一个整体来执行，服务器要么就执行事务中的所有操作，要么就一个操作也不执行**。

​		对于 Redis 的事务功能来说，**事务队列中的命令要么就全部都执行，要么就一个都不执行**，因此， Redis 的事务是具有原子性的。



#### 6.1.2  一致性

​		事务具有一致性指的是，**如果数据库在执行事务之前是一致的，那么在事务执行之后， 无论事务是否执行成功，数据库也应该仍然是一致的**。

​		“一致”指的是**数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据**。

​		Redis 通过**谨慎的错误检测和简单的设计**来保证事务的一致性



#### 6.1.3 隔离性

​		**即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响**，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。

​		因为 **Redis 使用单线程的方式来执行事务**（以及事务队列中的命令），并且服务器保证， **在执行事务期间不会对事务进行中断**，因此， Redis 的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。



#### 6.1.4 持久性

​		事务的耐久性指的是，**当一个事务执行完毕时，执行这个事务所得的结果巳经被保存到永久性存储介质**（比如硬盘）里面了，**即使服务器在事务执行完毕之后停机，执行事务所得的结果也不会丢失**。

​		因为 Redis 的事务不过是简单地用队列包裹起了一组 Redis 命令， Redis 并没有为事务提供任何额外的持久化功能，所以 **Redis 事务的耐久性由 Redis 所使用的持久化模式决定**：